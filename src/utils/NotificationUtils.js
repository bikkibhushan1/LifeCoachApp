import PushNotification from 'react-native-push-notification';
import AsyncStorage from '@react-native-community/async-storage';
import moment from 'moment';

export async function getID() {
  let id = await AsyncStorage.getItem('@notifID');
  console.log('notificationID ' + id);
  if (id) {
    let nextID = Number.parseInt(id) + 1;
    AsyncStorage.setItem('@notifID', nextID + '');
    return nextID;
  } else {
    AsyncStorage.setItem('@notifID', '0');
    return 0;
  }
}

export function configure(onRegister, onNotification, gcm = '') {
  PushNotification.configure({
    // (optional) Called when Token is generated (iOS and Android)
    onRegister: onRegister, //this._onRegister.bind(this),

    // (required) Called when a remote or local notification is opened or received
    onNotification: onNotification, //this._onNotification,

    // ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
    //   senderID: gcm,

    // IOS ONLY (optional): default: all - Permissions to register.
    permissions: {
      alert: true,
      badge: true,
      sound: true,
    },

    // Should the initial notification be popped automatically
    // default: true
    popInitialNotification: true,

    /**
     * (optional) default: true
     * - Specified if permissions (ios) and token (android and ios) will requested or not,
     * - if not, you must call PushNotificationsHandler.requestPermissions() later
     */
    requestPermissions: true,
  });
}

export function localNotif(id, title, message) {
  PushNotification.localNotification({
    /* Android Only Properties */
    id: '' + id, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
    ticker: 'My Notification Ticker', // (optional)
    autoCancel: false, // (optional) default: true
    largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
    smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
    // bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
    // subText: "This is a subText", // (optional) default: none
    // color: "red", // (optional) default: system default
    vibrate: true, // (optional) default: true
    vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
    // tag: "some_tag", // (optional) add tag to message
    // group: "group", // (optional) add group to message
    ongoing: false, // (optional) set whether this is an "ongoing" notification

    /* iOS only properties */
    alertAction: 'view', // (optional) default: view
    //   category: null, // (optional) default: null
    //   userInfo: null, // (optional) default: null (object containing additional notification data)

    /* iOS and Android properties */
    title: title, // (optional)
    message: message, // (required)
    playSound: false, // (optional) default: true
    soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
    // number: 10, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
    // actions: '["Yes", "No"]' // (Android only) See the doc for notification actions to know more
  });
}

export function scheduleNotif(
  id,
  title,
  message,
  date,
  repeatType,
  isAffirmation,
) {
  let notification = {
    date: date, // in 30 secs
    repeatType: repeatType,
    /* Android Only Properties */
    id: '' + id, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
    // ticker: "My Notification Ticker", // (optional)
    autoCancel: false, // (optional) default: true
    largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
    smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
    // bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
    // subText: "This is a subText", // (optional) default: none
    // color: "blue", // (optional) default: system default
    vibrate: true, // (optional) default: true
    vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
    tag: isAffirmation ? 'Affirmation' : 'Reminder', // (optional) add tag to message
    // group: "group", // (optional) add group to message
    ongoing: false, // (optional) set whether this is an "ongoing" notification
    isAffirmation: isAffirmation,
    type: isAffirmation ? 'Affirmation' : 'Reminder',
    number: 0,
    /* iOS only properties */
    alertAction: 'view', // (optional) default: view
    //   category: null, // (optional) default: null
    userInfo: {tag: isAffirmation ? 'Affirmation' : 'Reminder', id: '' + id}, // (optional) default: null (object containing additional notification data)

    /* iOS and Android properties */
    title: title, // (optional)
    message: message, // (required)
    playSound: true, // (optional) default: true
    soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
  };
  console.log('NOTIFICATION SCHEDULE', notification);
  PushNotification.localNotificationSchedule(notification);
}

export const scheduleDefaultReminder = async () => {
  console.log('SCHEDULE');
  const defaultReminderScheduled = await AsyncStorage.getItem(
    '@defaultReminder',
  );
  if (
    defaultReminderScheduled &&
    JSON.parse(defaultReminderScheduled) === true
  ) {
    return;
  }
  let notificationTime = moment();
  notificationTime.set('hours', 19);
  notificationTime.set('minutes', 0);
  const localNotification = {
    title: 'Daily Diary Card Entry',
    message: 'A gentle reminder to make you Daily Diary Entry',
    date: new Date(notificationTime.format()),
    days: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    id: [],
  };
  let notificationId = await getID();
  localNotification.id.push(notificationId);
  console.log('SCHEDULE DEFAULT', localNotification);
  scheduleNotif(
    notificationId,
    localNotification.title,
    localNotification.message,
    localNotification.date,
    'day',
    false,
  );
  const remindersJson = await AsyncStorage.getItem(getStorageConstant(false));
  let reminders = [];
  try {
    reminders = JSON.parse(remindersJson);
  } catch (error) {
    reminders = [];
    console.log(error);
  }
  if (!reminders) {
    reminders = [];
  }
  reminders.push(localNotification);
  AsyncStorage.setItem(getStorageConstant(false), JSON.stringify(reminders));
  AsyncStorage.setItem('@defaultReminder', JSON.stringify(true));
};

export function checkPermission(cbk) {
  return PushNotification.checkPermissions(cbk);
}

export function cancelNotif(id) {
  PushNotification.cancelLocalNotifications({id: '' + id});
}

export function cancelAll() {
  PushNotification.cancelAllLocalNotifications();
}

export const getUserAffirmations = () => {
  return AsyncStorage.getItem('@affirmations');
};

export const getUserReminders = () => {
  return AsyncStorage.getItem('@reminders');
};

export const getStorageConstant = isAffirmation => {
  return isAffirmation ? '@affirmations' : '@reminders';
};
